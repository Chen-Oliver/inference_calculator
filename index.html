<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inference Cost Calculator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: white;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .calculator {
            background: white;
            border: 1px solid #000;
            padding: 20px;
            max-width: 1400px;
            width: 100%;
        }

        h1 {
            color: #000;
            margin-bottom: 3px;
            font-size: 20px;
            font-weight: 600;
        }

        .subtitle {
            color: #666;
            margin-bottom: 15px;
            font-size: 12px;
            font-weight: 400;
        }

        .section {
            margin-bottom: 15px;
        }

        .config-section {
            background: #f5f5f5;
            border: 1px solid #000;
            padding: 15px;
            margin-bottom: 20px;
        }

        .config-inputs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .config-inputs > div {
            flex: 1;
            min-width: 250px;
        }

        .config-inputs > div:first-child,
        .config-inputs > div:nth-child(2) {
            min-width: 200px;
        }

        .model-select-container {
            min-width: 400px;
        }

        .cost-inputs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .cost-inputs > div {
            flex: 1;
        }

        .sections-row {
            display: flex;
            gap: 80px;
            margin-bottom: 15px;
            position: relative;
            align-items: stretch;
        }

        .sections-row::before {
            content: 'OR';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 6px 16px;
            border: 1px solid #000;
            font-size: 11px;
            font-weight: 600;
            z-index: 1;
        }

        .sections-row .section {
            flex: 1;
            margin-bottom: 0;
            border: 1px solid #000;
            padding: 15px;
        }

        .section-title {
            color: #000;
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        input, select {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #000;
            font-size: 13px;
            background: white;
        }

        select {
            cursor: pointer;
            width: 100%;
        }

        input:focus, select:focus {
            outline: none;
            background: #f5f5f5;
        }

        button {
            padding: 6px 12px;
            background: #000;
            color: white;
            border: 1px solid #000;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
        }

        button:hover {
            background: white;
            color: #000;
        }

        button:disabled {
            background: #ccc;
            border-color: #ccc;
            cursor: not-allowed;
        }

        .divider {
            text-align: center;
            margin: 12px 0;
            color: #666;
            font-size: 11px;
            position: relative;
        }

        .divider::before,
        .divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background: #000;
        }

        .divider::before {
            left: 0;
        }

        .divider::after {
            right: 0;
        }

        #result {
            margin-top: 15px;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .result {
            background: white;
            border: 1px solid #000;
            padding: 10px;
            text-align: center;
        }

        .result-label {
            color: #666;
            font-size: 10px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .result-value {
            color: #000;
            font-size: 24px;
            font-weight: 600;
        }

        .result-breakdown {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #000;
            font-size: 9px;
            color: #000;
            text-align: left;
            line-height: 1.4;
        }

        .result-breakdown div {
            margin: 2px 0;
        }

        .error {
            background: white;
            color: #000;
            border: 1px solid #000;
            padding: 10px;
            font-size: 12px;
            margin-top: 8px;
        }

        .info {
            background: white;
            color: #000;
            border: 1px solid #000;
            padding: 10px;
            font-size: 12px;
            margin-top: 8px;
        }

        .label {
            display: block;
            font-size: 11px;
            color: #000;
            margin-bottom: 4px;
            margin-top: 6px;
        }

        .label input[type="checkbox"] {
            width: auto;
            margin: 0 4px 0 0;
            vertical-align: middle;
        }

        .selected-models-list {
            max-height: 120px;
            overflow-y: auto;
            border: 1px solid #000;
            padding: 6px;
            min-height: 40px;
            background: #f9f9f9;
        }

        .model-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px;
            border-bottom: 1px solid #ddd;
            font-size: 11px;
        }

        .model-item:last-child {
            border-bottom: none;
        }

        .model-item span {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .model-item button {
            width: auto;
            padding: 2px 8px;
            margin: 0;
            margin-left: 8px;
            font-size: 10px;
            background: #fff;
            color: #000;
        }

        .model-item button:hover {
            background: #000;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="calculator">
        <h1>Inference Cost Calculator</h1>
        <p class="subtitle">Calculate per-request inference costs with cache-aware pricing</p>

        <div class="config-section">
            <div class="section-title">Shared Configuration</div>
            <div class="config-inputs">
                <div>
                    <label class="label">Number of requests</label>
                    <input
                        type="number"
                        id="numRequests"
                        value="107"
                        min="1"
                        step="1"
                    >
                </div>
                <div>
                    <label class="label">Times to sample (per request)</label>
                    <input
                        type="number"
                        id="timesToSample"
                        value="3"
                        min="1"
                        step="1"
                    >
                </div>
                <div class="model-select-container">
                    <label class="label">Judge Model</label>
                    <input
                        type="text"
                        id="judgeModelId"
                        placeholder="Start typing model name..."
                        value="deepseek/deepseek-r1-0528"
                        list="judgeModelList"
                        autocomplete="off"
                        style="width: 100%;"
                    >
                    <datalist id="judgeModelList"></datalist>
                </div>
            </div>
        </div>

        <div class="sections-row">
            <div class="section">
                <div class="section-title">Option 1: Select Model(s)</div>
                <label class="label">
                    <input type="checkbox" id="multiModelMode" onchange="toggleMultiModelMode()">
                    Multiple models (sum costs)
                </label>
                <div id="singleModelInput">
                    <label class="label">Model ID</label>
                    <input
                        type="text"
                        id="modelId"
                        placeholder="Start typing model name..."
                        value="openai/gpt-4o"
                        list="modelList"
                        autocomplete="off"
                        style="width: 100%;"
                    >
                    <datalist id="modelList"></datalist>
                </div>
                <div id="multiModelInput" style="display: none;">
                    <label class="label">Add models</label>
                    <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                        <input
                            type="text"
                            id="multiModelInput_field"
                            placeholder="Type or paste model IDs (comma/space/newline separated)..."
                            list="modelList"
                            autocomplete="off"
                            style="flex: 1;"
                            onkeypress="if(event.key==='Enter'){event.preventDefault();addModel();}"
                        >
                        <button type="button" onclick="addModel()" style="width: auto; padding: 6px 16px; margin: 0;">Add</button>
                    </div>
                    <div id="selectedModels" class="selected-models-list">
                        <div style="font-size: 11px; color: #666;">No models selected</div>
                    </div>
                </div>
                <button onclick="fetchPricing()" style="width: 100%; margin-top: 12px;">Calculate</button>
            </div>

            <div class="section">
                <div class="section-title">Option 2: Manual Input</div>
                <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                    <div style="flex: 1;">
                        <label class="label">Input cost per 1M tokens ($)</label>
                        <input
                            type="number"
                            id="inputCost"
                            placeholder="e.g., 2.50"
                            step="0.01"
                        >
                    </div>
                    <div style="flex: 1;">
                        <label class="label">Output cost per 1M tokens ($)</label>
                        <input
                            type="number"
                            id="outputCost"
                            placeholder="e.g., 10.00"
                            step="0.01"
                        >
                    </div>
                </div>
                <button onclick="calculateManual()" style="width: 100%;">Calculate</button>
            </div>
        </div>

        <div id="result"></div>
    </div>

    <script src="model_pricing_data.js"></script>
    <script>
        // Stats from custom_stats.json (fetched 2025-01-12)
        // Using overall mean for cached tokens (already accounts for cache hit rate)
        const STATS = {
            model: {
                cachedTokens: 1771  // overall mean (includes cache misses)
            },
            judge: {
                inputTokens: 8933,  // mean
                outputTokens: 774,  // mean
                cachedTokens: 5128  // overall mean (includes cache misses)
            }
        };

        const PERCENTILE_VALUES = {
            mean: {
                input: 4874,
                output: 879
            },
            p50: {
                input: 4787,
                output: 635
            },
            p75: {
                input: 5039,
                output: 1216
            },
            p90: {
                input: 5250,
                output: 1744
            },
            p95: {
                input: 5288,
                output: 2038
            },
            // p96: {
            //     input: 5294,
            //     output: 2135
            // },
            // p97: {
            //     input: 5300,
            //     output: 2290
            // },
            // p98: {
            //     input: 5310,
            //     output: 2481
            // },
            p99: {
                input: 5323,
                output: 2786
            }
        };

        // Populate datalists with all models on page load
        window.addEventListener('DOMContentLoaded', () => {
            const modelDatalist = document.getElementById('modelList');
            const judgeDatalist = document.getElementById('judgeModelList');

            Object.entries(MODEL_PRICING).forEach(([id, model]) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = `${model.name} - ${id}`;

                const option2 = option.cloneNode(true);
                modelDatalist.appendChild(option);
                judgeDatalist.appendChild(option2);
            });
        });

        let selectedModels = [];

        function toggleMultiModelMode() {
            const isMulti = document.getElementById('multiModelMode').checked;
            document.getElementById('singleModelInput').style.display = isMulti ? 'none' : 'block';
            document.getElementById('multiModelInput').style.display = isMulti ? 'block' : 'none';
            if (isMulti) {
                updateSelectedModelsList();
            }
        }

        function addModel() {
            const input = document.getElementById('multiModelInput_field');
            const inputValue = input.value.trim();

            if (!inputValue) {
                return;
            }

            // Split by commas, newlines, and/or spaces, then trim and filter empty strings
            const modelIds = inputValue
                .split(/[\n,\s]+/)
                .map(id => id.trim())
                .filter(id => id.length > 0);

            if (modelIds.length === 0) {
                return;
            }

            const added = [];
            const alreadyAdded = [];
            const notFound = [];

            modelIds.forEach(modelId => {
                if (selectedModels.includes(modelId)) {
                    alreadyAdded.push(modelId);
                } else if (MODEL_PRICING[modelId]) {
                    selectedModels.push(modelId);
                    added.push(modelId);
                } else {
                    notFound.push(modelId);
                }
            });

            input.value = '';
            updateSelectedModelsList();

            // Show summary message
            const messages = [];
            if (added.length > 0) {
                messages.push(`Added ${added.length} model${added.length > 1 ? 's' : ''}`);
            }
            if (alreadyAdded.length > 0) {
                messages.push(`${alreadyAdded.length} already in list`);
            }
            if (notFound.length > 0) {
                messages.push(`${notFound.length} not found: ${notFound.join(', ')}`);
            }

            if (messages.length > 0 && (alreadyAdded.length > 0 || notFound.length > 0)) {
                alert(messages.join('\n'));
            }
        }

        function removeModel(modelId) {
            selectedModels = selectedModels.filter(id => id !== modelId);
            updateSelectedModelsList();
        }

        function updateSelectedModelsList() {
            const container = document.getElementById('selectedModels');

            if (selectedModels.length === 0) {
                container.innerHTML = '<div style="font-size: 11px; color: #666;">No models selected</div>';
                return;
            }

            let html = '';
            selectedModels.forEach(modelId => {
                const model = MODEL_PRICING[modelId];
                html += `
                    <div class="model-item">
                        <span title="${model.name}">${model.name}</span>
                        <button type="button" onclick="removeModel('${modelId.replace(/'/g, "\\'")}')">Remove</button>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function fetchPricing() {
            const isMulti = document.getElementById('multiModelMode').checked;
            const judgeModelId = document.getElementById('judgeModelId').value.trim();
            const resultDiv = document.getElementById('result');

            if (!judgeModelId) {
                resultDiv.innerHTML = '<div class="error">Please enter a judge model ID</div>';
                return;
            }

            const judgeModel = MODEL_PRICING[judgeModelId];
            if (!judgeModel) {
                resultDiv.innerHTML = `<div class="error">Judge model "${judgeModelId}" not found. Try typing to see autocomplete suggestions.</div>`;
                return;
            }

            if (isMulti) {
                // Multi-model mode: calculate each model separately then sum costs
                if (selectedModels.length === 0) {
                    resultDiv.innerHTML = '<div class="error">Please add at least one model</div>';
                    return;
                }

                const numRequests = parseInt(document.getElementById('numRequests').value) || 1;
                const timesToSample = parseInt(document.getElementById('timesToSample').value) || 1;

                const judgeInputCost = parseFloat(judgeModel.prompt);
                const judgeOutputCost = parseFloat(judgeModel.completion);
                const judgeInputCacheRead = judgeModel.inputCacheRead ? parseFloat(judgeModel.inputCacheRead) : null;
                const judgeInputCacheWrite = judgeModel.inputCacheWrite ? parseFloat(judgeModel.inputCacheWrite) : null;

                // Calculate judge costs once
                const judgeInputTokens = STATS.judge.inputTokens;
                const judgeOutputTokens = STATS.judge.outputTokens;
                const judgeCachedTokens = STATS.judge.cachedTokens;
                const judgeUncachedTokens = judgeInputTokens - judgeCachedTokens;

                const judgeNoCachePerAttempt = (judgeInputTokens * judgeInputCost) + (judgeOutputTokens * judgeOutputCost);

                let judgePerAttemptWithCache = judgeNoCachePerAttempt;
                if (judgeInputCacheRead || judgeInputCacheWrite) {
                    const judgeInputCost_uncached = judgeUncachedTokens * judgeInputCost;
                    const judgeInputCost_cached = judgeCachedTokens * (judgeInputCacheRead || judgeInputCost);
                    const judgeOutputCostCalc = judgeOutputTokens * judgeOutputCost;
                    judgePerAttemptWithCache = judgeInputCost_uncached + judgeInputCost_cached + judgeOutputCostCalc;
                }

                // Calculate each model separately
                const modelCosts = {};
                
                Object.entries(PERCENTILE_VALUES).forEach(([percentile, values]) => {
                    if (!modelCosts[percentile]) {
                        modelCosts[percentile] = {
                            noCache: { total: 0, byModel: {} },
                            withCache: { total: 0, byModel: {} }
                        };
                    }

                    const modelCachedTokens = STATS.model.cachedTokens;
                    const modelUncachedTokens = values.input - modelCachedTokens;

                    selectedModels.forEach(modelId => {
                        const model = MODEL_PRICING[modelId];
                        const inputCostPerToken = parseFloat(model.prompt);
                        const outputCostPerToken = parseFloat(model.completion);
                        const inputCacheRead = model.inputCacheRead ? parseFloat(model.inputCacheRead) : null;
                        const inputCacheWrite = model.inputCacheWrite ? parseFloat(model.inputCacheWrite) : null;

                        // NO CACHE
                        const modelNoCachePerAttempt = (values.input * inputCostPerToken) + (values.output * outputCostPerToken);
                        const modelNoCachePerRequest = (modelNoCachePerAttempt + judgeNoCachePerAttempt) * timesToSample;
                        const modelNoCache = modelNoCachePerRequest * numRequests;
                        
                        modelCosts[percentile].noCache.byModel[modelId] = {
                            name: model.name,
                            modelCost: modelNoCachePerAttempt * timesToSample * numRequests,
                            judgeCost: judgeNoCachePerAttempt * timesToSample * numRequests,
                            total: modelNoCache
                        };
                        modelCosts[percentile].noCache.total += modelNoCache;

                        // WITH CACHE
                        let modelFirstAttempt = modelNoCachePerAttempt;
                        let modelLaterAttempt = modelNoCachePerAttempt;

                        if (inputCacheWrite || inputCacheRead) {
                            if (inputCacheWrite) {
                                const modelFirstInputCost = values.input * inputCostPerToken;
                                const modelFirstCacheWriteCost = modelCachedTokens * inputCacheWrite;
                                const modelFirstOutputCost = values.output * outputCostPerToken;
                                modelFirstAttempt = modelFirstInputCost + modelFirstCacheWriteCost + modelFirstOutputCost;
                            }

                            if (inputCacheRead) {
                                const modelLaterInputCost = modelUncachedTokens * inputCostPerToken;
                                const modelLaterCacheCost = modelCachedTokens * inputCacheRead;
                                const modelLaterOutputCost = values.output * outputCostPerToken;
                                modelLaterAttempt = modelLaterInputCost + modelLaterCacheCost + modelLaterOutputCost;
                            }
                        }

                        const firstAttemptTotal = modelFirstAttempt + judgePerAttemptWithCache;
                        const laterAttemptsTotal = (timesToSample - 1) * (modelLaterAttempt + judgePerAttemptWithCache);
                        const modelWithCachePerRequest = firstAttemptTotal + laterAttemptsTotal;
                        const modelWithCache = modelWithCachePerRequest * numRequests;

                        modelCosts[percentile].withCache.byModel[modelId] = {
                            name: model.name,
                            modelCost: (modelFirstAttempt + (timesToSample - 1) * modelLaterAttempt) * numRequests,
                            judgeCost: judgePerAttemptWithCache * timesToSample * numRequests,
                            total: modelWithCache
                        };
                        modelCosts[percentile].withCache.total += modelWithCache;
                    });
                });

                const modelNames = selectedModels.map(id => MODEL_PRICING[id].name);

                calculateCostMultiModel(
                    modelCosts,
                    `Multiple Models (${selectedModels.length}): ${modelNames.join(', ')}`,
                    judgeModel.name
                );
            } else {
                // Single model mode
                const modelId = document.getElementById('modelId').value.trim();

                if (!modelId) {
                    resultDiv.innerHTML = '<div class="error">Please enter a model ID</div>';
                    return;
                }

                const model = MODEL_PRICING[modelId];

                if (!model) {
                    resultDiv.innerHTML = `<div class="error">Model "${modelId}" not found. Try typing to see autocomplete suggestions.</div>`;
                    return;
                }

                const inputCostPerToken = parseFloat(model.prompt);
                const outputCostPerToken = parseFloat(model.completion);
                const inputCacheRead = model.inputCacheRead ? parseFloat(model.inputCacheRead) : null;
                const inputCacheWrite = model.inputCacheWrite ? parseFloat(model.inputCacheWrite) : null;

                const judgeInputCost = parseFloat(judgeModel.prompt);
                const judgeOutputCost = parseFloat(judgeModel.completion);
                const judgeInputCacheRead = judgeModel.inputCacheRead ? parseFloat(judgeModel.inputCacheRead) : null;
                const judgeInputCacheWrite = judgeModel.inputCacheWrite ? parseFloat(judgeModel.inputCacheWrite) : null;

                calculateCost(
                    inputCostPerToken,
                    outputCostPerToken,
                    inputCacheRead,
                    inputCacheWrite,
                    judgeInputCost,
                    judgeOutputCost,
                    judgeInputCacheRead,
                    judgeInputCacheWrite,
                    model.name,
                    judgeModel.name,
                    1  // Single model
                );
            }
        }

        function calculateManual() {
            const inputCostPer1M = parseFloat(document.getElementById('inputCost').value);
            const outputCostPer1M = parseFloat(document.getElementById('outputCost').value);
            const judgeModelId = document.getElementById('judgeModelId').value.trim();
            const resultDiv = document.getElementById('result');

            if (isNaN(inputCostPer1M) || isNaN(outputCostPer1M)) {
                resultDiv.innerHTML = '<div class="error">Please enter valid numbers for both costs</div>';
                return;
            }

            if (!judgeModelId) {
                resultDiv.innerHTML = '<div class="error">Please select a judge model</div>';
                return;
            }

            const judgeModel = MODEL_PRICING[judgeModelId];
            if (!judgeModel) {
                resultDiv.innerHTML = `<div class="error">Judge model "${judgeModelId}" not found.</div>`;
                return;
            }

            const inputCostPerToken = inputCostPer1M / 1_000_000;
            const outputCostPerToken = outputCostPer1M / 1_000_000;

            const judgeInputCost = parseFloat(judgeModel.prompt);
            const judgeOutputCost = parseFloat(judgeModel.completion);
            const judgeInputCacheRead = judgeModel.inputCacheRead ? parseFloat(judgeModel.inputCacheRead) : null;
            const judgeInputCacheWrite = judgeModel.inputCacheWrite ? parseFloat(judgeModel.inputCacheWrite) : null;

            calculateCost(
                inputCostPerToken,
                outputCostPerToken,
                null, // no cache pricing for manual input
                null,
                judgeInputCost,
                judgeOutputCost,
                judgeInputCacheRead,
                judgeInputCacheWrite,
                'Manual Model',
                judgeModel.name,
                1  // Single model
            );
        }

        function calculateCost(
            inputCostPerToken,
            outputCostPerToken,
            inputCacheRead,
            inputCacheWrite,
            judgeInputCost,
            judgeOutputCost,
            judgeInputCacheRead,
            judgeInputCacheWrite,
            modelName = null,
            judgeModelName = null,
            numModels = 1
        ) {
            const numRequests = parseInt(document.getElementById('numRequests').value) || 1;
            const timesToSample = parseInt(document.getElementById('timesToSample').value) || 1;

            const resultDiv = document.getElementById('result');
            let headerHtml = '';
            let gridHtml = '';

            // Add header info
            if (modelName && judgeModelName) {
                headerHtml += `<div style="font-size: 12px; color: #666; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #000;">
                    <strong>Model:</strong> ${modelName} | <strong>Judge:</strong> ${judgeModelName}
                </div>`;
            }

            headerHtml += `<div style="font-size: 11px; color: #666; margin-bottom: 10px;">
                <strong>Model:</strong> Input: $${(inputCostPerToken * 1_000_000).toFixed(2)}/1M | Output: $${(outputCostPerToken * 1_000_000).toFixed(2)}/1M
                ${inputCacheRead ? ` | Cache Read: $${(inputCacheRead * 1_000_000).toFixed(2)}/1M` : ''}
                ${inputCacheWrite ? ` | Cache Write: $${(inputCacheWrite * 1_000_000).toFixed(2)}/1M` : ''}
                <br>
                <strong>Judge:</strong> Input: $${(judgeInputCost * 1_000_000).toFixed(2)}/1M | Output: $${(judgeOutputCost * 1_000_000).toFixed(2)}/1M
                ${judgeInputCacheRead ? ` | Cache Read: $${(judgeInputCacheRead * 1_000_000).toFixed(2)}/1M` : ''}
                ${judgeInputCacheWrite ? ` | Cache Write: $${(judgeInputCacheWrite * 1_000_000).toFixed(2)}/1M` : ''}
            </div>`;

            // Calculate judge costs (using fixed conservative mean)
            const judgeInputTokens = STATS.judge.inputTokens;
            const judgeOutputTokens = STATS.judge.outputTokens;
            const judgeCachedTokens = STATS.judge.cachedTokens;
            const judgeUncachedTokens = judgeInputTokens - judgeCachedTokens;

            // Calculate for all percentiles (using fixed conservative mean for cache)
            Object.entries(PERCENTILE_VALUES).forEach(([percentile, values]) => {
                const modelCachedTokens = STATS.model.cachedTokens;
                const modelUncachedTokens = values.input - modelCachedTokens;

                // === NO CACHE CALCULATION (BASELINE) ===
                const modelNoCachePerAttempt = (values.input * inputCostPerToken) + (values.output * outputCostPerToken);
                const judgeNoCachePerAttempt = (judgeInputTokens * judgeInputCost) + (judgeOutputTokens * judgeOutputCost);
                // Judge evaluates each model's samples, so multiply by numModels
                const noCacheCostPerRequest = (modelNoCachePerAttempt + judgeNoCachePerAttempt * numModels) * timesToSample;
                const noCacheTotalCost = noCacheCostPerRequest * numRequests;

                // === WITH CACHE CALCULATION ===
                let withCacheTotalCost = noCacheTotalCost;
                let hasCache = false;
                let modelFirstAttempt = modelNoCachePerAttempt;
                let modelLaterAttempt = modelNoCachePerAttempt;
                let judgeFirstAttempt = judgeNoCachePerAttempt;
                let judgeLaterAttempt = judgeNoCachePerAttempt;
                let withCacheCostPerRequest = noCacheCostPerRequest;

                if (inputCacheRead || inputCacheWrite || judgeInputCacheRead || judgeInputCacheWrite) {
                    hasCache = true;

                    // MODEL RESPONSE - First attempt
                    if (inputCacheWrite) {
                        const modelFirstInputCost = values.input * inputCostPerToken;
                        const modelFirstCacheWriteCost = modelCachedTokens * inputCacheWrite;
                        const modelFirstOutputCost = values.output * outputCostPerToken;
                        modelFirstAttempt = modelFirstInputCost + modelFirstCacheWriteCost + modelFirstOutputCost;
                    }

                    // MODEL RESPONSE - Later attempts (cache read)
                    if (inputCacheRead) {
                        const modelLaterInputCost = modelUncachedTokens * inputCostPerToken;
                        const modelLaterCacheCost = modelCachedTokens * inputCacheRead;
                        const modelLaterOutputCost = values.output * outputCostPerToken;
                        modelLaterAttempt = modelLaterInputCost + modelLaterCacheCost + modelLaterOutputCost;
                    }

                    // JUDGE RESPONSE - All attempts (cache hit rate ~2/3 already built into mean)
                    // Use same calculation for all attempts since overall mean already accounts for
                    // the distribution (1st attempt = no cache, 2nd/3rd = cache hit)
                    let judgePerAttemptWithCache = judgeNoCachePerAttempt;
                    if (judgeInputCacheRead || judgeInputCacheWrite) {
                        const judgeInputCost_uncached = judgeUncachedTokens * judgeInputCost;
                        const judgeInputCost_cached = judgeCachedTokens * (judgeInputCacheRead || judgeInputCost);
                        const judgeOutputCostCalc = judgeOutputTokens * judgeOutputCost;
                        judgePerAttemptWithCache = judgeInputCost_uncached + judgeInputCost_cached + judgeOutputCostCalc;
                    }
                    judgeFirstAttempt = judgePerAttemptWithCache;
                    judgeLaterAttempt = judgePerAttemptWithCache;

                    // Total per request with cache
                    // Judge evaluates each model's samples, so multiply by numModels
                    const firstAttemptTotal = modelFirstAttempt + judgeFirstAttempt * numModels;
                    const laterAttemptsTotal = (timesToSample - 1) * (modelLaterAttempt + judgeLaterAttempt * numModels);
                    withCacheCostPerRequest = firstAttemptTotal + laterAttemptsTotal;
                    withCacheTotalCost = withCacheCostPerRequest * numRequests;
                }

                const savings = noCacheTotalCost - withCacheTotalCost;
                const savingsPercent = hasCache ? ((savings / noCacheTotalCost) * 100) : 0;

                // Build detailed breakdown - NO CACHE
                let breakdownNoCache = `<strong style="color: #666;">WITHOUT CACHE:</strong><br>`;
                breakdownNoCache += `<span style="font-size: 9px;">Model per attempt:</span><br>`;
                breakdownNoCache += `- Input: ${values.input.toLocaleString()}t × $${(inputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.input * inputCostPerToken).toFixed(4)}<br>`;
                breakdownNoCache += `- Output: ${values.output.toLocaleString()}t × $${(outputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.output * outputCostPerToken).toFixed(4)}<br>`;
                breakdownNoCache += `= $${modelNoCachePerAttempt.toFixed(4)}<br>`;
                breakdownNoCache += `<span style="font-size: 9px;">Judge per attempt:</span><br>`;
                breakdownNoCache += `- Input: ${judgeInputTokens.toLocaleString()}t × $${(judgeInputCost * 1_000_000).toFixed(2)}/1M = $${(judgeInputTokens * judgeInputCost).toFixed(4)}<br>`;
                breakdownNoCache += `- Output: ${judgeOutputTokens.toLocaleString()}t × $${(judgeOutputCost * 1_000_000).toFixed(2)}/1M = $${(judgeOutputTokens * judgeOutputCost).toFixed(4)}<br>`;
                breakdownNoCache += `= $${judgeNoCachePerAttempt.toFixed(4)}${numModels > 1 ? ` × ${numModels} models` : ''}<br>`;
                breakdownNoCache += `<br><strong>Per request:</strong> $${noCacheCostPerRequest.toFixed(4)}<br>`;
                breakdownNoCache += `<strong>× ${numRequests.toLocaleString()} requests = $${noCacheTotalCost.toFixed(2)}</strong>`;

                // Build detailed breakdown - WITH CACHE (if applicable)
                let breakdownWithCache = '';
                if (hasCache) {
                    breakdownWithCache = `<br><br><strong style="color: #000;">WITH CACHE:</strong><br>`;
                    breakdownWithCache += `<strong>Model Response:</strong><br>`;
                    breakdownWithCache += `<span style="font-size: 9px;">First attempt:</span><br>`;
                    breakdownWithCache += `- Input: ${values.input.toLocaleString()}t × $${(inputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.input * inputCostPerToken).toFixed(4)}<br>`;
                    if (inputCacheWrite) {
                        breakdownWithCache += `- Cache write: ${modelCachedTokens.toLocaleString()}t × $${(inputCacheWrite * 1_000_000).toFixed(2)}/1M = $${(modelCachedTokens * inputCacheWrite).toFixed(4)}<br>`;
                    } else if (inputCacheRead) {
                        breakdownWithCache += `- Cache write: ${modelCachedTokens.toLocaleString()}t × $0.00/1M = $0.0000 (free)<br>`;
                    }
                    breakdownWithCache += `- Output: ${values.output.toLocaleString()}t × $${(outputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.output * outputCostPerToken).toFixed(4)}<br>`;
                    breakdownWithCache += `= $${modelFirstAttempt.toFixed(4)}<br>`;

                    if (timesToSample > 1) {
                        breakdownWithCache += `<span style="font-size: 9px;">Later attempts (×${timesToSample - 1}):</span><br>`;
                        if (inputCacheRead) {
                            breakdownWithCache += `- Uncached: ${modelUncachedTokens.toLocaleString()}t × $${(inputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(modelUncachedTokens * inputCostPerToken).toFixed(4)}<br>`;
                            breakdownWithCache += `- Cache read: ${modelCachedTokens.toLocaleString()}t × $${(inputCacheRead * 1_000_000).toFixed(2)}/1M = $${(modelCachedTokens * inputCacheRead).toFixed(4)}<br>`;
                        } else {
                            breakdownWithCache += `- Input: ${values.input.toLocaleString()}t × $${(inputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.input * inputCostPerToken).toFixed(4)}<br>`;
                        }
                        breakdownWithCache += `- Output: ${values.output.toLocaleString()}t × $${(outputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.output * outputCostPerToken).toFixed(4)}<br>`;
                        breakdownWithCache += `= $${modelLaterAttempt.toFixed(4)} × ${timesToSample - 1}<br>`;
                    }

                    breakdownWithCache += `<br><strong>Judge Response:</strong><br>`;
                    if (judgeInputCacheRead) {
                        // Judge has cache read support - show cached breakdown
                        breakdownWithCache += `<span style="font-size: 9px;">All attempts (×${timesToSample}${numModels > 1 ? ` × ${numModels} models` : ''}):</span><br>`;
                        breakdownWithCache += `- Uncached: ${judgeUncachedTokens.toLocaleString()}t × $${(judgeInputCost * 1_000_000).toFixed(2)}/1M = $${(judgeUncachedTokens * judgeInputCost).toFixed(4)}<br>`;
                        breakdownWithCache += `- Cached (avg): ${judgeCachedTokens.toLocaleString()}t × $${(judgeInputCacheRead * 1_000_000).toFixed(2)}/1M = $${(judgeCachedTokens * judgeInputCacheRead).toFixed(4)}<br>`;
                        breakdownWithCache += `- Output: ${judgeOutputTokens.toLocaleString()}t × $${(judgeOutputCost * 1_000_000).toFixed(2)}/1M = $${(judgeOutputTokens * judgeOutputCost).toFixed(4)}<br>`;
                        breakdownWithCache += `= $${judgeFirstAttempt.toFixed(4)} × ${timesToSample}${numModels > 1 ? ` × ${numModels}` : ''}<br>`;
                    } else {
                        // Judge has no cache support - show regular cost per attempt
                        breakdownWithCache += `<span style="font-size: 9px;">Per attempt (×${timesToSample}${numModels > 1 ? ` × ${numModels} models` : ''}):</span><br>`;
                        breakdownWithCache += `- Input: ${judgeInputTokens.toLocaleString()}t × $${(judgeInputCost * 1_000_000).toFixed(2)}/1M = $${(judgeInputTokens * judgeInputCost).toFixed(4)}<br>`;
                        breakdownWithCache += `- Output: ${judgeOutputTokens.toLocaleString()}t × $${(judgeOutputCost * 1_000_000).toFixed(2)}/1M = $${(judgeOutputTokens * judgeOutputCost).toFixed(4)}<br>`;
                        breakdownWithCache += `= $${judgeNoCachePerAttempt.toFixed(4)} × ${timesToSample}${numModels > 1 ? ` × ${numModels}` : ''}<br>`;
                    }

                    breakdownWithCache += `<br><strong>Per request:</strong> $${withCacheCostPerRequest.toFixed(4)}<br>`;
                    breakdownWithCache += `<strong>× ${numRequests.toLocaleString()} requests = $${withCacheTotalCost.toFixed(2)}</strong>`;
                }

                const breakdown = breakdownNoCache + breakdownWithCache;

                gridHtml += `
                    <div class="result">
                        <div class="result-label">${percentile.toUpperCase()}</div>
                        <div class="result-value" style="font-size: 18px; margin-bottom: 5px;">
                            <div style="color: #666; font-size: 10px; font-weight: normal; margin-bottom: 3px;">WITHOUT CACHE</div>
                            $${noCacheTotalCost.toFixed(2)}
                        </div>
                        ${hasCache ? `
                            <div class="result-value" style="font-size: 18px; margin-bottom: 5px;">
                                <div style="color: #666; font-size: 10px; font-weight: normal; margin-bottom: 3px;">WITH CACHE</div>
                                $${withCacheTotalCost.toFixed(2)}
                            </div>
                            <div style="font-size: 11px; color: #000; margin-bottom: 8px; padding: 4px; background: #f0f0f0; border: 1px solid #ccc;">
                                <strong>Savings:</strong> $${savings.toFixed(2)} (${savingsPercent.toFixed(1)}%)
                            </div>
                        ` : ''}
                        <div class="result-breakdown">
                            ${breakdown}
                        </div>
                    </div>
                `;
            });

            resultDiv.innerHTML = headerHtml + '<div class="results-grid">' + gridHtml + '</div>';
        }

        function calculateCostMultiModel(modelCosts, modelName, judgeModelName) {
            const resultDiv = document.getElementById('result');
            let headerHtml = '';
            let gridHtml = '';

            // Add header info
            if (modelName && judgeModelName) {
                headerHtml += `<div style="font-size: 12px; color: #666; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #000;">
                    <strong>Model:</strong> ${modelName} | <strong>Judge:</strong> ${judgeModelName}
                </div>`;
            }

            // Calculate for all percentiles
            Object.entries(PERCENTILE_VALUES).forEach(([percentile, values]) => {
                const costs = modelCosts[percentile];
                const noCacheTotalCost = costs.noCache.total;
                const withCacheTotalCost = costs.withCache.total;
                const hasCache = Object.values(costs.withCache.byModel).some(m => 
                    costs.withCache.byModel[Object.keys(costs.withCache.byModel)[0]].total !== 
                    costs.noCache.byModel[Object.keys(costs.noCache.byModel)[0]].total
                );

                const savings = noCacheTotalCost - withCacheTotalCost;
                const savingsPercent = hasCache ? ((savings / noCacheTotalCost) * 100) : 0;

                // Build pie chart canvas
                const chartId = `chart_${percentile}`;
                const chartHtml = hasCache ? `
                    <div style="margin-top: 15px; padding: 10px; background: #fafafa; border: 1px solid #ddd;">
                        <div style="font-size: 11px; font-weight: 600; margin-bottom: 8px; text-align: center;">Cost Breakdown (WITH CACHE)</div>
                        <canvas id="${chartId}" width="250" height="250"></canvas>
                    </div>
                ` : '';

                // Build detailed breakdown
                let breakdownHtml = `<strong style="color: #666;">WITHOUT CACHE:</strong><br>`;
                Object.entries(costs.noCache.byModel).forEach(([modelId, data]) => {
                    breakdownHtml += `<strong>${data.name}:</strong><br>`;
                    breakdownHtml += `- Model: $${data.modelCost.toFixed(4)}<br>`;
                    breakdownHtml += `- Judge: $${data.judgeCost.toFixed(4)}<br>`;
                    breakdownHtml += `= $${data.total.toFixed(4)}<br>`;
                });
                breakdownHtml += `<strong>Total: $${noCacheTotalCost.toFixed(2)}</strong>`;

                if (hasCache) {
                    breakdownHtml += `<br><br><strong style="color: #000;">WITH CACHE:</strong><br>`;
                    Object.entries(costs.withCache.byModel).forEach(([modelId, data]) => {
                        breakdownHtml += `<strong>${data.name}:</strong><br>`;
                        breakdownHtml += `- Model: $${data.modelCost.toFixed(4)}<br>`;
                        breakdownHtml += `- Judge: $${data.judgeCost.toFixed(4)}<br>`;
                        breakdownHtml += `= $${data.total.toFixed(4)}<br>`;
                    });
                    breakdownHtml += `<strong>Total: $${withCacheTotalCost.toFixed(2)}</strong>`;
                }

                gridHtml += `
                    <div class="result">
                        <div class="result-label">${percentile.toUpperCase()}</div>
                        <div class="result-value" style="font-size: 18px; margin-bottom: 5px;">
                            <div style="color: #666; font-size: 10px; font-weight: normal; margin-bottom: 3px;">WITHOUT CACHE</div>
                            $${noCacheTotalCost.toFixed(2)}
                        </div>
                        ${hasCache ? `
                            <div class="result-value" style="font-size: 18px; margin-bottom: 5px;">
                                <div style="color: #666; font-size: 10px; font-weight: normal; margin-bottom: 3px;">WITH CACHE</div>
                                $${withCacheTotalCost.toFixed(2)}
                            </div>
                            <div style="font-size: 11px; color: #000; margin-bottom: 8px; padding: 4px; background: #f0f0f0; border: 1px solid #ccc;">
                                <strong>Savings:</strong> $${savings.toFixed(2)} (${savingsPercent.toFixed(1)}%)
                            </div>
                        ` : ''}
                        <div class="result-breakdown">
                            ${breakdownHtml}
                        </div>
                        ${chartHtml}
                    </div>
                `;

                // Draw pie chart after rendering
                if (hasCache) {
                    setTimeout(() => {
                        const ctx = document.getElementById(chartId);
                        if (ctx) {
                            const chartData = [];
                            const chartLabels = [];
                            const chartColors = [
                                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                                '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
                            ];

                            Object.entries(costs.withCache.byModel).forEach(([modelId, data], idx) => {
                                chartLabels.push(`${data.name} (Model)`);
                                chartData.push(data.modelCost);
                                chartLabels.push(`${data.name} (Judge)`);
                                chartData.push(data.judgeCost);
                            });

                            new Chart(ctx, {
                                type: 'pie',
                                data: {
                                    labels: chartLabels,
                                    datasets: [{
                                        data: chartData,
                                        backgroundColor: chartColors,
                                        borderWidth: 1
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: true,
                                    plugins: {
                                        legend: {
                                            position: 'bottom',
                                            labels: {
                                                font: { size: 9 },
                                                padding: 8
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                label: function(context) {
                                                    const label = context.label || '';
                                                    const value = context.parsed || 0;
                                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                                    const percentage = ((value / total) * 100).toFixed(1);
                                                    return `${label}: $${value.toFixed(4)} (${percentage}%)`;
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    }, 100);
                }
            });

            resultDiv.innerHTML = headerHtml + '<div class="results-grid">' + gridHtml + '</div>';
        }

        // Allow Enter key to trigger fetch
        document.getElementById('modelId').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                fetchPricing();
            }
        });

        document.getElementById('judgeModelId').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                fetchPricing();
            }
        });
    </script>
</body>
</html>
