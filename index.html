<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inference Cost Calculator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: white;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .calculator {
            background: white;
            border: 1px solid #000;
            padding: 20px;
            max-width: 1400px;
            width: 100%;
        }

        h1 {
            color: #000;
            margin-bottom: 3px;
            font-size: 20px;
            font-weight: 600;
        }

        .subtitle {
            color: #666;
            margin-bottom: 15px;
            font-size: 12px;
            font-weight: 400;
        }

        .section {
            margin-bottom: 15px;
        }

        .config-section {
            background: #f5f5f5;
            border: 1px solid #000;
            padding: 15px;
            margin-bottom: 20px;
        }

        .config-inputs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .config-inputs > div {
            flex: 1;
            min-width: 250px;
        }

        .config-inputs > div:first-child,
        .config-inputs > div:nth-child(2) {
            min-width: 200px;
        }

        .model-select-container {
            min-width: 400px;
        }

        .cost-inputs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .cost-inputs > div {
            flex: 1;
        }

        .sections-row {
            display: flex;
            gap: 80px;
            margin-bottom: 15px;
            position: relative;
            align-items: stretch;
        }

        .sections-row::before {
            content: 'OR';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 6px 16px;
            border: 1px solid #000;
            font-size: 11px;
            font-weight: 600;
            z-index: 1;
        }

        .sections-row .section {
            flex: 1;
            margin-bottom: 0;
            border: 1px solid #000;
            padding: 15px;
        }

        .section-title {
            color: #000;
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        input, select {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #000;
            font-size: 13px;
            background: white;
        }

        select {
            cursor: pointer;
            width: 100%;
        }

        input:focus, select:focus {
            outline: none;
            background: #f5f5f5;
        }

        button {
            padding: 6px 12px;
            background: #000;
            color: white;
            border: 1px solid #000;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
        }

        button:hover {
            background: white;
            color: #000;
        }

        button:disabled {
            background: #ccc;
            border-color: #ccc;
            cursor: not-allowed;
        }

        .divider {
            text-align: center;
            margin: 12px 0;
            color: #666;
            font-size: 11px;
            position: relative;
        }

        .divider::before,
        .divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background: #000;
        }

        .divider::before {
            left: 0;
        }

        .divider::after {
            right: 0;
        }

        #result {
            margin-top: 15px;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .result {
            background: white;
            border: 1px solid #000;
            padding: 10px;
            text-align: center;
        }

        .result-label {
            color: #666;
            font-size: 10px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .result-value {
            color: #000;
            font-size: 24px;
            font-weight: 600;
        }

        .result-breakdown {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #000;
            font-size: 9px;
            color: #000;
            text-align: left;
            line-height: 1.4;
        }

        .result-breakdown div {
            margin: 2px 0;
        }

        .error {
            background: white;
            color: #000;
            border: 1px solid #000;
            padding: 10px;
            font-size: 12px;
            margin-top: 8px;
        }

        .info {
            background: white;
            color: #000;
            border: 1px solid #000;
            padding: 10px;
            font-size: 12px;
            margin-top: 8px;
        }

        .label {
            display: block;
            font-size: 11px;
            color: #000;
            margin-bottom: 4px;
            margin-top: 6px;
        }

        .label input[type="checkbox"] {
            width: auto;
            margin: 0 4px 0 0;
            vertical-align: middle;
        }

        .selected-models-list {
            max-height: 120px;
            overflow-y: auto;
            border: 1px solid #000;
            padding: 6px;
            min-height: 40px;
            background: #f9f9f9;
        }

        .model-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px;
            border-bottom: 1px solid #ddd;
            font-size: 11px;
        }

        .model-item:last-child {
            border-bottom: none;
        }

        .model-item span {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .model-item button {
            width: auto;
            padding: 2px 8px;
            margin: 0;
            margin-left: 8px;
            font-size: 10px;
            background: #fff;
            color: #000;
        }

        .model-item button:hover {
            background: #000;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="calculator">
        <h1>Inference Cost Calculator</h1>
        <p class="subtitle">Calculate per-request inference costs with cache-aware pricing</p>

        <div class="config-section">
            <div class="section-title">Shared Configuration</div>
            <div class="config-inputs">
                <div>
                    <label class="label">Number of requests</label>
                    <input
                        type="number"
                        id="numRequests"
                        value="107"
                        min="1"
                        step="1"
                    >
                </div>
                <div>
                    <label class="label">Times to sample (per request)</label>
                    <input
                        type="number"
                        id="timesToSample"
                        value="3"
                        min="1"
                        step="1"
                    >
                </div>
                <div class="model-select-container">
                    <label class="label">Judge Model</label>
                    <input
                        type="text"
                        id="judgeModelId"
                        placeholder="Start typing model name..."
                        value="deepseek/deepseek-r1-0528"
                        list="judgeModelList"
                        autocomplete="off"
                        style="width: 100%;"
                    >
                    <datalist id="judgeModelList"></datalist>
                </div>
                <div style="margin-top: 12px;">
                    <label class="label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="ignoreAnthropicCache" checked>
                        <span>Ignore Anthropic/Claude cache pricing (cache writes are costly and off by default)</span>
                    </label>
                </div>
            </div>
        </div>

        <div class="sections-row">
            <div class="section">
                <div class="section-title">Option 1: Select Model(s)</div>
                <label class="label">Add models</label>
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <input
                        type="text"
                        id="multiModelInput_field"
                        placeholder="Type or paste model IDs (comma/space/newline separated)..."
                        list="modelList"
                        autocomplete="off"
                        style="flex: 1;"
                        onkeypress="if(event.key==='Enter'){event.preventDefault();addModel();}"
                    >
                    <button type="button" onclick="addModel()" style="width: auto; padding: 6px 16px; margin: 0;">Add</button>
                </div>
                <div id="selectedModels" class="selected-models-list">
                    <div style="font-size: 11px; color: #666;">No models selected</div>
                </div>
                <datalist id="modelList"></datalist>
                <button onclick="fetchPricing()" style="width: 100%; margin-top: 12px;">Calculate</button>
            </div>

            <div class="section">
                <div class="section-title">Option 2: Manual Input</div>
                <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                    <div style="flex: 1;">
                        <label class="label">Input cost per 1M tokens ($)</label>
                        <input
                            type="number"
                            id="inputCost"
                            placeholder="e.g., 3.00"
                            step="0.01"
                            value="3.00"
                        >
                    </div>
                    <div style="flex: 1;">
                        <label class="label">Output cost per 1M tokens ($)</label>
                        <input
                            type="number"
                            id="outputCost"
                            placeholder="e.g., 15.00"
                            step="0.01"
                            value="15.00"
                        >
                    </div>
                </div>
                <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                    <div style="flex: 1;">
                        <label class="label">Cache Read cost per 1M tokens ($)</label>
                        <input
                            type="number"
                            id="inputCacheReadCost"
                            placeholder="e.g., 0.30"
                            step="0.01"
                            value="0.30"
                        >
                    </div>
                    <div style="flex: 1;">
                        <label class="label">Cache Write cost per 1M tokens ($)</label>
                        <input
                            type="number"
                            id="inputCacheWriteCost"
                            placeholder="e.g., 3.75"
                            step="0.01"
                            value="3.75"
                        >
                    </div>
                </div>
                <button onclick="calculateManual()" style="width: 100%;">Calculate</button>
            </div>
        </div>

        <div id="result"></div>
    </div>

    <script src="model_pricing_data.js"></script>
    <script>
        // Stats from custom_stats.json
        const STATS = {
            model: {
                // overall mean for cache reads (conservative - includes cache misses)
                cachedTokensOverall: 1771,
                // conditional mean for cache writes (actual amount written when write occurs)
                cachedTokensConditional: 4363
            },
            judge: {
                inputTokens: 8933,
                outputTokens: 774,
                // overall mean for cache reads (conservative - includes cache misses)
                cachedTokensOverall: 5128,
                // conditional mean for cache writes (actual amount written when write occurs)
                cachedTokensConditional: 7509
            }
        };

        const PERCENTILE_VALUES = {
            mean: {
                input: 4875,
                output: 885
            },
            p50: {
                input: 4787,
                output: 641
            },
            p75: {
                input: 5039,
                output: 1222
            },
            p90: {
                input: 5253,
                output: 1745
            },
            p95: {
                input: 5288,
                output: 2039
            },
            // p96: {
            //     input: 5294,
            //     output: 2135
            // },
            // p97: {
            //     input: 5300,
            //     output: 2297
            // },
            // p98: {
            //     input: 5310,
            //     output: 2481
            // },
            p99: {
                input: 5323,
                output: 2786
            }
        };

        // Populate datalists with all models on page load
        window.addEventListener('DOMContentLoaded', () => {
            const modelDatalist = document.getElementById('modelList');
            const judgeDatalist = document.getElementById('judgeModelList');

            Object.entries(MODEL_PRICING).forEach(([id, model]) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = `${model.name} - ${id}`;

                const option2 = option.cloneNode(true);
                modelDatalist.appendChild(option);
                judgeDatalist.appendChild(option2);
            });
        });

        let selectedModels = [];

        function addModel() {
            const input = document.getElementById('multiModelInput_field');
            const inputValue = input.value.trim();

            if (!inputValue) {
                return;
            }

            // Split by commas, newlines, and/or spaces, then trim and filter empty strings
            const modelIds = inputValue
                .split(/[\n,\s]+/)
                .map(id => id.trim())
                .filter(id => id.length > 0);

            if (modelIds.length === 0) {
                return;
            }

            const added = [];
            const alreadyAdded = [];
            const notFound = [];

            modelIds.forEach(modelId => {
                if (selectedModels.includes(modelId)) {
                    alreadyAdded.push(modelId);
                } else if (MODEL_PRICING[modelId]) {
                    selectedModels.push(modelId);
                    added.push(modelId);
                } else {
                    notFound.push(modelId);
                }
            });

            input.value = '';
            updateSelectedModelsList();

            // Show summary message
            const messages = [];
            if (added.length > 0) {
                messages.push(`Added ${added.length} model${added.length > 1 ? 's' : ''}`);
            }
            if (alreadyAdded.length > 0) {
                messages.push(`${alreadyAdded.length} already in list`);
            }
            if (notFound.length > 0) {
                messages.push(`${notFound.length} not found: ${notFound.join(', ')}`);
            }

            if (messages.length > 0 && (alreadyAdded.length > 0 || notFound.length > 0)) {
                alert(messages.join('\n'));
            }
        }

        function removeModel(modelId) {
            selectedModels = selectedModels.filter(id => id !== modelId);
            updateSelectedModelsList();
        }

        function updateSelectedModelsList() {
            const container = document.getElementById('selectedModels');

            if (selectedModels.length === 0) {
                container.innerHTML = '<div style="font-size: 11px; color: #666;">No models selected</div>';
                return;
            }

            let html = '';
            selectedModels.forEach(modelId => {
                const model = MODEL_PRICING[modelId];
                html += `
                    <div class="model-item">
                        <span title="${model.name}">${model.name}</span>
                        <button type="button" onclick="removeModel('${modelId.replace(/'/g, "\\'")}')">Remove</button>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function fetchPricing() {
            const judgeModelId = document.getElementById('judgeModelId').value.trim();
            const resultDiv = document.getElementById('result');

            if (!judgeModelId) {
                resultDiv.innerHTML = '<div class="error">Please enter a judge model ID</div>';
                return;
            }

            const judgeModel = MODEL_PRICING[judgeModelId];
            if (!judgeModel) {
                resultDiv.innerHTML = `<div class="error">Judge model "${judgeModelId}" not found. Try typing to see autocomplete suggestions.</div>`;
                return;
            }

            if (selectedModels.length === 0) {
                resultDiv.innerHTML = '<div class="error">Please add at least one model</div>';
                return;
            }

                const numRequests = parseInt(document.getElementById('numRequests').value) || 1;
                const timesToSample = parseInt(document.getElementById('timesToSample').value) || 1;

                const judgeInputCost = parseFloat(judgeModel.prompt);
                const judgeOutputCost = parseFloat(judgeModel.completion);

                // Check if we should ignore Anthropic cache for judge
                const ignoreAnthropicCache = document.getElementById('ignoreAnthropicCache').checked;
                const isAnthropicJudge = judgeModelId.startsWith('anthropic/');

                const judgeInputCacheRead = (judgeModel.inputCacheRead && !(ignoreAnthropicCache && isAnthropicJudge)) ? parseFloat(judgeModel.inputCacheRead) : null;
                const judgeInputCacheWrite = (judgeModel.inputCacheWrite && !(ignoreAnthropicCache && isAnthropicJudge)) ? parseFloat(judgeModel.inputCacheWrite) : null;

                // Calculate judge costs once
                const judgeInputTokens = STATS.judge.inputTokens;
                const judgeOutputTokens = STATS.judge.outputTokens;
                const judgeCachedTokensRead = STATS.judge.cachedTokensOverall;
                const judgeCachedTokensWrite = STATS.judge.cachedTokensConditional;
                const judgeUncachedTokens = judgeInputTokens - judgeCachedTokensRead;

                const judgeNoCachePerAttempt = (judgeInputTokens * judgeInputCost) + (judgeOutputTokens * judgeOutputCost);

                let judgePerAttemptWithCache = judgeNoCachePerAttempt;
                if (judgeInputCacheRead || judgeInputCacheWrite) {
                    const judgeInputCost_uncached = judgeUncachedTokens * judgeInputCost;
                    const judgeInputCost_cached = judgeCachedTokensRead * (judgeInputCacheRead || judgeInputCost);
                    const judgeOutputCostCalc = judgeOutputTokens * judgeOutputCost;
                    judgePerAttemptWithCache = judgeInputCost_uncached + judgeInputCost_cached + judgeOutputCostCalc;
                }

                // Calculate each model separately
                const modelCosts = {};
                
                Object.entries(PERCENTILE_VALUES).forEach(([percentile, values]) => {
                    if (!modelCosts[percentile]) {
                        modelCosts[percentile] = {
                            noCache: { total: 0, byModel: {} },
                            withCache: { total: 0, byModel: {} }
                        };
                    }

                    const modelCachedTokensRead = STATS.model.cachedTokensOverall;
                    const modelCachedTokensWrite = STATS.model.cachedTokensConditional;
                    const modelUncachedTokens = values.input - modelCachedTokensRead;

                    selectedModels.forEach(modelId => {
                        const model = MODEL_PRICING[modelId];
                        const inputCostPerToken = parseFloat(model.prompt);
                        const outputCostPerToken = parseFloat(model.completion);

                        // Check if we should ignore Anthropic cache
                        const ignoreAnthropicCache = document.getElementById('ignoreAnthropicCache').checked;
                        const isAnthropicModel = modelId.startsWith('anthropic/');

                        const inputCacheRead = (model.inputCacheRead && !(ignoreAnthropicCache && isAnthropicModel)) ? parseFloat(model.inputCacheRead) : null;
                        const inputCacheWrite = (model.inputCacheWrite && !(ignoreAnthropicCache && isAnthropicModel)) ? parseFloat(model.inputCacheWrite) : null;

                        // NO CACHE
                        const modelNoCachePerAttempt = (values.input * inputCostPerToken) + (values.output * outputCostPerToken);
                        const modelNoCachePerRequest = (modelNoCachePerAttempt + judgeNoCachePerAttempt) * timesToSample;
                        const modelNoCache = modelNoCachePerRequest * numRequests;

                        modelCosts[percentile].noCache.byModel[modelId] = {
                            name: model.name,
                            modelCost: modelNoCachePerAttempt * timesToSample * numRequests,
                            judgeCost: judgeNoCachePerAttempt * timesToSample * numRequests,
                            total: modelNoCache
                        };
                        modelCosts[percentile].noCache.total += modelNoCache;

                        // WITH CACHE
                        let modelFirstAttempt = modelNoCachePerAttempt;
                        let modelLaterAttempt = modelNoCachePerAttempt;

                        if (inputCacheWrite || inputCacheRead) {
                            if (inputCacheWrite) {
                                const modelFirstInputCost = values.input * inputCostPerToken;
                                const modelFirstCacheWriteCost = modelCachedTokensWrite * inputCacheWrite;
                                const modelFirstOutputCost = values.output * outputCostPerToken;
                                modelFirstAttempt = modelFirstInputCost + modelFirstCacheWriteCost + modelFirstOutputCost;
                            }

                            if (inputCacheRead) {
                                const modelLaterInputCost = modelUncachedTokens * inputCostPerToken;
                                const modelLaterCacheCost = modelCachedTokensRead * inputCacheRead;
                                const modelLaterOutputCost = values.output * outputCostPerToken;
                                modelLaterAttempt = modelLaterInputCost + modelLaterCacheCost + modelLaterOutputCost;
                            }
                        }

                        const firstAttemptTotal = modelFirstAttempt + judgePerAttemptWithCache;
                        const laterAttemptsTotal = (timesToSample - 1) * (modelLaterAttempt + judgePerAttemptWithCache);
                        const modelWithCachePerRequest = firstAttemptTotal + laterAttemptsTotal;
                        const modelWithCache = modelWithCachePerRequest * numRequests;

                        modelCosts[percentile].withCache.byModel[modelId] = {
                            name: model.name,
                            modelCost: (modelFirstAttempt + (timesToSample - 1) * modelLaterAttempt) * numRequests,
                            judgeCost: judgePerAttemptWithCache * timesToSample * numRequests,
                            total: modelWithCache
                        };
                        modelCosts[percentile].withCache.total += modelWithCache;
                    });
                });

            const modelNames = selectedModels.map(id => MODEL_PRICING[id].name);

            calculateCostMultiModel(
                modelCosts,
                `Multiple Models (${selectedModels.length}): ${modelNames.join(', ')}`,
                judgeModel.name
            );
        }

        function calculateManual() {
            const inputCostPer1M = parseFloat(document.getElementById('inputCost').value);
            const outputCostPer1M = parseFloat(document.getElementById('outputCost').value);
            const inputCacheReadPer1M = parseFloat(document.getElementById('inputCacheReadCost').value);
            const inputCacheWritePer1M = parseFloat(document.getElementById('inputCacheWriteCost').value);
            const judgeModelId = document.getElementById('judgeModelId').value.trim();
            const resultDiv = document.getElementById('result');

            if (isNaN(inputCostPer1M) || isNaN(outputCostPer1M)) {
                resultDiv.innerHTML = '<div class="error">Please enter valid numbers for input and output costs</div>';
                return;
            }

            if (!judgeModelId) {
                resultDiv.innerHTML = '<div class="error">Please select a judge model</div>';
                return;
            }

            const judgeModel = MODEL_PRICING[judgeModelId];
            if (!judgeModel) {
                resultDiv.innerHTML = `<div class="error">Judge model "${judgeModelId}" not found.</div>`;
                return;
            }

            const inputCostPerToken = inputCostPer1M / 1_000_000;
            const outputCostPerToken = outputCostPer1M / 1_000_000;
            const inputCacheRead = !isNaN(inputCacheReadPer1M) ? inputCacheReadPer1M / 1_000_000 : null;
            const inputCacheWrite = !isNaN(inputCacheWritePer1M) ? inputCacheWritePer1M / 1_000_000 : null;

            const judgeInputCost = parseFloat(judgeModel.prompt);
            const judgeOutputCost = parseFloat(judgeModel.completion);
            const judgeInputCacheRead = judgeModel.inputCacheRead ? parseFloat(judgeModel.inputCacheRead) : null;
            const judgeInputCacheWrite = judgeModel.inputCacheWrite ? parseFloat(judgeModel.inputCacheWrite) : null;

            calculateCost(
                inputCostPerToken,
                outputCostPerToken,
                inputCacheRead,
                inputCacheWrite,
                judgeInputCost,
                judgeOutputCost,
                judgeInputCacheRead,
                judgeInputCacheWrite,
                'Manual Model',
                judgeModel.name,
                1  // Single model
            );
        }

        function calculateCost(
            inputCostPerToken,
            outputCostPerToken,
            inputCacheRead,
            inputCacheWrite,
            judgeInputCost,
            judgeOutputCost,
            judgeInputCacheRead,
            judgeInputCacheWrite,
            modelName = null,
            judgeModelName = null,
            numModels = 1
        ) {
            const numRequests = parseInt(document.getElementById('numRequests').value) || 1;
            const timesToSample = parseInt(document.getElementById('timesToSample').value) || 1;

            const resultDiv = document.getElementById('result');
            let headerHtml = '';
            let gridHtml = '';

            // Add header info
            if (modelName && judgeModelName) {
                headerHtml += `<div style="font-size: 12px; color: #666; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #000;">
                    <strong>Model:</strong> ${modelName} | <strong>Judge:</strong> ${judgeModelName}
                </div>`;
            }

            headerHtml += `<div style="font-size: 11px; color: #666; margin-bottom: 10px;">
                <strong>Model:</strong> Input: $${(inputCostPerToken * 1_000_000).toFixed(2)}/1M | Output: $${(outputCostPerToken * 1_000_000).toFixed(2)}/1M
                ${inputCacheRead ? ` | Cache Read: $${(inputCacheRead * 1_000_000).toFixed(2)}/1M` : ''}
                ${inputCacheWrite ? ` | Cache Write: $${(inputCacheWrite * 1_000_000).toFixed(2)}/1M` : ''}
                <br>
                <strong>Judge:</strong> Input: $${(judgeInputCost * 1_000_000).toFixed(2)}/1M | Output: $${(judgeOutputCost * 1_000_000).toFixed(2)}/1M
                ${judgeInputCacheRead ? ` | Cache Read: $${(judgeInputCacheRead * 1_000_000).toFixed(2)}/1M` : ''}
                ${judgeInputCacheWrite ? ` | Cache Write: $${(judgeInputCacheWrite * 1_000_000).toFixed(2)}/1M` : ''}
            </div>`;

            // Calculate judge costs
            const judgeInputTokens = STATS.judge.inputTokens;
            const judgeOutputTokens = STATS.judge.outputTokens;
            const judgeCachedTokensRead = STATS.judge.cachedTokensOverall;  // conservative for reads
            const judgeCachedTokensWrite = STATS.judge.cachedTokensConditional;  // actual write amount
            const judgeUncachedTokens = judgeInputTokens - judgeCachedTokensRead;

            // Calculate for all percentiles
            Object.entries(PERCENTILE_VALUES).forEach(([percentile, values]) => {
                const modelCachedTokensRead = STATS.model.cachedTokensOverall;  // conservative for reads
                const modelCachedTokensWrite = STATS.model.cachedTokensConditional;  // actual write amount
                const modelUncachedTokens = values.input - modelCachedTokensRead;

                // === NO CACHE CALCULATION (BASELINE) ===
                const modelNoCachePerAttempt = (values.input * inputCostPerToken) + (values.output * outputCostPerToken);
                const judgeNoCachePerAttempt = (judgeInputTokens * judgeInputCost) + (judgeOutputTokens * judgeOutputCost);
                // Judge evaluates each model's samples, so multiply by numModels
                const noCacheCostPerRequest = (modelNoCachePerAttempt + judgeNoCachePerAttempt * numModels) * timesToSample;
                const noCacheTotalCost = noCacheCostPerRequest * numRequests;

                // === WITH CACHE CALCULATION ===
                let withCacheTotalCost = noCacheTotalCost;
                let hasCache = false;
                let modelFirstAttempt = modelNoCachePerAttempt;
                let modelLaterAttempt = modelNoCachePerAttempt;
                let judgeFirstAttempt = judgeNoCachePerAttempt;
                let judgeLaterAttempt = judgeNoCachePerAttempt;
                let withCacheCostPerRequest = noCacheCostPerRequest;

                if (inputCacheRead || inputCacheWrite || judgeInputCacheRead || judgeInputCacheWrite) {
                    hasCache = true;

                    // MODEL RESPONSE - First attempt (cache write)
                    if (inputCacheWrite) {
                        const modelFirstInputCost = values.input * inputCostPerToken;
                        const modelFirstCacheWriteCost = modelCachedTokensWrite * inputCacheWrite;  // Use conditional mean
                        const modelFirstOutputCost = values.output * outputCostPerToken;
                        modelFirstAttempt = modelFirstInputCost + modelFirstCacheWriteCost + modelFirstOutputCost;
                    }

                    // MODEL RESPONSE - Later attempts (cache read)
                    if (inputCacheRead) {
                        const modelLaterInputCost = modelUncachedTokens * inputCostPerToken;
                        const modelLaterCacheCost = modelCachedTokensRead * inputCacheRead;  // Use overall mean (conservative)
                        const modelLaterOutputCost = values.output * outputCostPerToken;
                        modelLaterAttempt = modelLaterInputCost + modelLaterCacheCost + modelLaterOutputCost;
                    }

                    // JUDGE RESPONSE - All attempts (cache hit rate ~2/3 already built into mean)
                    // Use same calculation for all attempts since overall mean already accounts for
                    // the distribution (1st attempt = no cache, 2nd/3rd = cache hit)
                    let judgePerAttemptWithCache = judgeNoCachePerAttempt;
                    if (judgeInputCacheRead || judgeInputCacheWrite) {
                        const judgeInputCost_uncached = judgeUncachedTokens * judgeInputCost;
                        const judgeInputCost_cached = judgeCachedTokensRead * (judgeInputCacheRead || judgeInputCost);
                        const judgeOutputCostCalc = judgeOutputTokens * judgeOutputCost;
                        judgePerAttemptWithCache = judgeInputCost_uncached + judgeInputCost_cached + judgeOutputCostCalc;
                    }
                    judgeFirstAttempt = judgePerAttemptWithCache;
                    judgeLaterAttempt = judgePerAttemptWithCache;

                    // Total per request with cache
                    // Judge evaluates each model's samples, so multiply by numModels
                    const firstAttemptTotal = modelFirstAttempt + judgeFirstAttempt * numModels;
                    const laterAttemptsTotal = (timesToSample - 1) * (modelLaterAttempt + judgeLaterAttempt * numModels);
                    withCacheCostPerRequest = firstAttemptTotal + laterAttemptsTotal;
                    withCacheTotalCost = withCacheCostPerRequest * numRequests;
                }

                const savings = noCacheTotalCost - withCacheTotalCost;
                const savingsPercent = hasCache ? ((savings / noCacheTotalCost) * 100) : 0;

                // Build detailed breakdown - NO CACHE
                let breakdownNoCache = `<strong style="color: #666;">WITHOUT CACHE:</strong><br>`;
                breakdownNoCache += `<span style="font-size: 9px;">Model per attempt:</span><br>`;
                breakdownNoCache += `- Input: ${values.input.toLocaleString()}t × $${(inputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.input * inputCostPerToken).toFixed(4)}<br>`;
                breakdownNoCache += `- Output: ${values.output.toLocaleString()}t × $${(outputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.output * outputCostPerToken).toFixed(4)}<br>`;
                breakdownNoCache += `= $${modelNoCachePerAttempt.toFixed(4)}<br>`;
                breakdownNoCache += `<span style="font-size: 9px;">Judge per attempt:</span><br>`;
                breakdownNoCache += `- Input: ${judgeInputTokens.toLocaleString()}t × $${(judgeInputCost * 1_000_000).toFixed(2)}/1M = $${(judgeInputTokens * judgeInputCost).toFixed(4)}<br>`;
                breakdownNoCache += `- Output: ${judgeOutputTokens.toLocaleString()}t × $${(judgeOutputCost * 1_000_000).toFixed(2)}/1M = $${(judgeOutputTokens * judgeOutputCost).toFixed(4)}<br>`;
                breakdownNoCache += `= $${judgeNoCachePerAttempt.toFixed(4)}${numModels > 1 ? ` × ${numModels} models` : ''}<br>`;
                breakdownNoCache += `<br><strong>Per request:</strong> $${noCacheCostPerRequest.toFixed(4)}<br>`;
                breakdownNoCache += `<strong>× ${numRequests.toLocaleString()} requests = $${noCacheTotalCost.toFixed(2)}</strong>`;

                // Build detailed breakdown - WITH CACHE (if applicable)
                let breakdownWithCache = '';
                if (hasCache) {
                    breakdownWithCache = `<br><br><strong style="color: #000;">WITH CACHE:</strong><br>`;
                    breakdownWithCache += `<strong>Model Response:</strong><br>`;
                    breakdownWithCache += `<span style="font-size: 9px;">First attempt:</span><br>`;
                    breakdownWithCache += `- Input: ${values.input.toLocaleString()}t × $${(inputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.input * inputCostPerToken).toFixed(4)}<br>`;
                    if (inputCacheWrite) {
                        breakdownWithCache += `- Cache write: ${modelCachedTokensWrite.toLocaleString()}t × $${(inputCacheWrite * 1_000_000).toFixed(2)}/1M = $${(modelCachedTokensWrite * inputCacheWrite).toFixed(4)}<br>`;
                    } else if (inputCacheRead) {
                        breakdownWithCache += `- Cache write: ${modelCachedTokensWrite.toLocaleString()}t × $0.00/1M = $0.0000 (free)<br>`;
                    }
                    breakdownWithCache += `- Output: ${values.output.toLocaleString()}t × $${(outputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.output * outputCostPerToken).toFixed(4)}<br>`;
                    breakdownWithCache += `= $${modelFirstAttempt.toFixed(4)}<br>`;

                    if (timesToSample > 1) {
                        breakdownWithCache += `<span style="font-size: 9px;">Later attempts (×${timesToSample - 1}):</span><br>`;
                        if (inputCacheRead) {
                            breakdownWithCache += `- Uncached: ${modelUncachedTokens.toLocaleString()}t × $${(inputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(modelUncachedTokens * inputCostPerToken).toFixed(4)}<br>`;
                            breakdownWithCache += `- Cache read: ${modelCachedTokensRead.toLocaleString()}t × $${(inputCacheRead * 1_000_000).toFixed(2)}/1M = $${(modelCachedTokensRead * inputCacheRead).toFixed(4)}<br>`;
                        } else {
                            breakdownWithCache += `- Input: ${values.input.toLocaleString()}t × $${(inputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.input * inputCostPerToken).toFixed(4)}<br>`;
                        }
                        breakdownWithCache += `- Output: ${values.output.toLocaleString()}t × $${(outputCostPerToken * 1_000_000).toFixed(2)}/1M = $${(values.output * outputCostPerToken).toFixed(4)}<br>`;
                        breakdownWithCache += `= $${modelLaterAttempt.toFixed(4)} × ${timesToSample - 1}<br>`;
                    }

                    breakdownWithCache += `<br><strong>Judge Response:</strong><br>`;
                    if (judgeInputCacheRead) {
                        // Judge has cache read support - show cached breakdown
                        breakdownWithCache += `<span style="font-size: 9px;">All attempts (×${timesToSample}${numModels > 1 ? ` × ${numModels} models` : ''}):</span><br>`;
                        breakdownWithCache += `- Uncached: ${judgeUncachedTokens.toLocaleString()}t × $${(judgeInputCost * 1_000_000).toFixed(2)}/1M = $${(judgeUncachedTokens * judgeInputCost).toFixed(4)}<br>`;
                        breakdownWithCache += `- Cached (avg): ${judgeCachedTokensRead.toLocaleString()}t × $${(judgeInputCacheRead * 1_000_000).toFixed(2)}/1M = $${(judgeCachedTokensRead * judgeInputCacheRead).toFixed(4)}<br>`;
                        breakdownWithCache += `- Output: ${judgeOutputTokens.toLocaleString()}t × $${(judgeOutputCost * 1_000_000).toFixed(2)}/1M = $${(judgeOutputTokens * judgeOutputCost).toFixed(4)}<br>`;
                        breakdownWithCache += `= $${judgeFirstAttempt.toFixed(4)} × ${timesToSample}${numModels > 1 ? ` × ${numModels}` : ''}<br>`;
                    } else {
                        // Judge has no cache support - show regular cost per attempt
                        breakdownWithCache += `<span style="font-size: 9px;">Per attempt (×${timesToSample}${numModels > 1 ? ` × ${numModels} models` : ''}):</span><br>`;
                        breakdownWithCache += `- Input: ${judgeInputTokens.toLocaleString()}t × $${(judgeInputCost * 1_000_000).toFixed(2)}/1M = $${(judgeInputTokens * judgeInputCost).toFixed(4)}<br>`;
                        breakdownWithCache += `- Output: ${judgeOutputTokens.toLocaleString()}t × $${(judgeOutputCost * 1_000_000).toFixed(2)}/1M = $${(judgeOutputTokens * judgeOutputCost).toFixed(4)}<br>`;
                        breakdownWithCache += `= $${judgeNoCachePerAttempt.toFixed(4)} × ${timesToSample}${numModels > 1 ? ` × ${numModels}` : ''}<br>`;
                    }

                    breakdownWithCache += `<br><strong>Per request:</strong> $${withCacheCostPerRequest.toFixed(4)}<br>`;
                    breakdownWithCache += `<strong>× ${numRequests.toLocaleString()} requests = $${withCacheTotalCost.toFixed(2)}</strong>`;
                }

                const breakdown = breakdownNoCache + breakdownWithCache;

                gridHtml += `
                    <div class="result">
                        <div class="result-label">${percentile.toUpperCase()}</div>
                        <div class="result-value" style="font-size: 18px; margin-bottom: 5px;">
                            <div style="color: #666; font-size: 10px; font-weight: normal; margin-bottom: 3px;">WITHOUT CACHE</div>
                            $${noCacheTotalCost.toFixed(2)}
                        </div>
                        ${hasCache ? `
                            <div class="result-value" style="font-size: 18px; margin-bottom: 5px;">
                                <div style="color: #666; font-size: 10px; font-weight: normal; margin-bottom: 3px;">WITH CACHE</div>
                                $${withCacheTotalCost.toFixed(2)}
                            </div>
                            <div style="font-size: 11px; color: #000; margin-bottom: 8px; padding: 4px; background: #f0f0f0; border: 1px solid #ccc;">
                                <strong>Savings:</strong> $${savings.toFixed(2)} (${savingsPercent.toFixed(1)}%)
                            </div>
                        ` : ''}
                        <div class="result-breakdown">
                            ${breakdown}
                        </div>
                    </div>
                `;
            });

            resultDiv.innerHTML = headerHtml + '<div class="results-grid">' + gridHtml + '</div>';
        }

        function calculateCostMultiModel(modelCosts, modelName, judgeModelName) {
            const resultDiv = document.getElementById('result');
            let headerHtml = '';
            let gridHtml = '';

            // Add header info
            if (modelName && judgeModelName) {
                headerHtml += `<div style="font-size: 12px; color: #666; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #000;">
                    <strong>Model:</strong> ${modelName} | <strong>Judge:</strong> ${judgeModelName}
                </div>`;
            }

            // Store chart data for rendering after DOM update
            const chartsToRender = [];

            // Calculate for all percentiles
            Object.entries(PERCENTILE_VALUES).forEach(([percentile, values]) => {
                const costs = modelCosts[percentile];
                const noCacheTotalCost = costs.noCache.total;
                const withCacheTotalCost = costs.withCache.total;
                const hasCache = withCacheTotalCost !== noCacheTotalCost;

                const savings = noCacheTotalCost - withCacheTotalCost;
                const savingsPercent = hasCache ? ((savings / noCacheTotalCost) * 100) : 0;

                // Build detailed breakdown
                let breakdownHtml = `<strong style="color: #666;">WITHOUT CACHE:</strong><br>`;
                Object.entries(costs.noCache.byModel).forEach(([modelId, data]) => {
                    breakdownHtml += `<strong>${data.name}:</strong><br>`;
                    breakdownHtml += `- Model: $${data.modelCost.toFixed(4)}<br>`;
                    breakdownHtml += `- Judge: $${data.judgeCost.toFixed(4)}<br>`;
                    breakdownHtml += `= $${data.total.toFixed(4)}<br>`;
                });
                breakdownHtml += `<strong>Total: $${noCacheTotalCost.toFixed(2)}</strong>`;

                if (hasCache) {
                    breakdownHtml += `<br><br><strong style="color: #000;">WITH CACHE:</strong><br>`;
                    Object.entries(costs.withCache.byModel).forEach(([modelId, data]) => {
                        breakdownHtml += `<strong>${data.name}:</strong><br>`;
                        breakdownHtml += `- Model: $${data.modelCost.toFixed(4)}<br>`;
                        breakdownHtml += `- Judge: $${data.judgeCost.toFixed(4)}<br>`;
                        breakdownHtml += `= $${data.total.toFixed(4)}<br>`;
                    });
                    breakdownHtml += `<strong>Total: $${withCacheTotalCost.toFixed(2)}</strong>`;
                }

                gridHtml += `
                    <div class="result">
                        <div class="result-label">${percentile.toUpperCase()}</div>
                        <div class="result-value" style="font-size: 18px; margin-bottom: 5px;">
                            <div style="color: #666; font-size: 10px; font-weight: normal; margin-bottom: 3px;">WITHOUT CACHE</div>
                            $${noCacheTotalCost.toFixed(2)}
                        </div>
                        ${hasCache ? `
                            <div class="result-value" style="font-size: 18px; margin-bottom: 5px;">
                                <div style="color: #666; font-size: 10px; font-weight: normal; margin-bottom: 3px;">WITH CACHE</div>
                                $${withCacheTotalCost.toFixed(2)}
                            </div>
                            <div style="font-size: 11px; color: #000; margin-bottom: 8px; padding: 4px; background: #f0f0f0; border: 1px solid #ccc;">
                                <strong>Savings:</strong> $${savings.toFixed(2)} (${savingsPercent.toFixed(1)}%)
                            </div>
                        ` : ''}
                        <div class="result-breakdown">
                            ${breakdownHtml}
                        </div>
                    </div>
                `;

                // Store chart data for later rendering
                if (hasCache) {
                    const chartId = `chart_${percentile}`;
                    chartsToRender.push({
                        chartId,
                        percentile: percentile.toUpperCase(),
                        costsData: JSON.parse(JSON.stringify(costs.withCache.byModel))  // Deep copy
                    });
                }
            });

            // Build charts section HTML
            let chartsHtml = '';
            if (chartsToRender.length > 0) {
                chartsHtml = `
                    <div style="margin-top: 30px; padding: 20px; background: #fafafa; border: 1px solid #ddd; border-radius: 4px;">
                        <h3 style="margin: 0 0 20px 0; font-size: 16px; text-align: center;">Cost Breakdown Charts (WITH CACHE)</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); gap: 20px;">
                            ${chartsToRender.map(chart => `
                                <div style="padding: 15px; background: white; border: 1px solid #ccc; border-radius: 4px;">
                                    <div style="font-size: 13px; font-weight: 600; margin-bottom: 10px; text-align: center;">${chart.percentile}</div>
                                    <div style="position: relative; height: 450px;">
                                        <canvas id="${chart.chartId}"></canvas>
                                    </div>
                                </div>
                            `).join('')}
                        </div>

                        <div style="margin-top: 30px;">
                            <h3 style="margin: 0 0 20px 0; font-size: 16px; text-align: center;">Cumulative Cost Analysis (Cheapest to Most Expensive)</h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(500px, 1fr)); gap: 20px;">
                                ${chartsToRender.map(chart => `
                                    <div style="padding: 15px; background: white; border: 1px solid #ccc; border-radius: 4px;">
                                        <div style="font-size: 13px; font-weight: 600; margin-bottom: 10px; text-align: center;">${chart.percentile}</div>
                                        <div style="position: relative; height: 400px;">
                                            <canvas id="${chart.chartId}_cumulative"></canvas>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }

            // Set HTML first
            resultDiv.innerHTML = headerHtml + '<div class="results-grid">' + gridHtml + '</div>' + chartsHtml;

            // Render all charts after DOM is updated
            setTimeout(() => {
                chartsToRender.forEach(chartInfo => {
                    const ctx = document.getElementById(chartInfo.chartId);
                    if (ctx) {
                        const chartColors = [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                            '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
                        ];

                        // Sort by total cost (descending) for pie chart
                        const sortedEntries = Object.entries(chartInfo.costsData)
                            .map(([modelId, data]) => ({
                                modelId,
                                name: data.name,
                                modelCost: data.modelCost,
                                judgeCost: data.judgeCost,
                                total: data.modelCost + data.judgeCost
                            }))
                            .sort((a, b) => b.total - a.total);

                        const chartData = sortedEntries.map(entry => entry.total);
                        const chartLabels = sortedEntries.map(entry => entry.name);
                        const sortedCostsData = sortedEntries.map(entry => ({
                            modelCost: entry.modelCost,
                            judgeCost: entry.judgeCost
                        }));

                        // Render pie chart with better legend handling
                        new Chart(ctx, {
                            type: 'pie',
                            data: {
                                labels: chartLabels,
                                datasets: [{
                                    data: chartData,
                                    backgroundColor: chartColors,
                                    borderWidth: 1
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        position: 'bottom',
                                        labels: {
                                            font: { size: 10 },
                                            padding: 10,
                                            boxWidth: 15,
                                            boxHeight: 15
                                        },
                                        maxHeight: 120
                                    },
                                    tooltip: {
                                        callbacks: {
                                            label: function(context) {
                                                const label = context.label || '';
                                                const value = context.parsed || 0;
                                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                                const percentage = ((value / total) * 100).toFixed(1);

                                                const modelData = sortedCostsData[context.dataIndex];
                                                if (modelData) {
                                                    return [
                                                        `${label}: $${value.toFixed(4)} (${percentage}%)`,
                                                        `  Model: $${modelData.modelCost.toFixed(4)}`,
                                                        `  Judge: $${modelData.judgeCost.toFixed(4)}`
                                                    ];
                                                }
                                                return `${label}: $${value.toFixed(4)} (${percentage}%)`;
                                            }
                                        }
                                    }
                                },
                                layout: {
                                    padding: {
                                        top: 10,
                                        bottom: 10
                                    }
                                }
                            }
                        });

                        // Render cumulative cost chart
                        const ctxCumulative = document.getElementById(`${chartInfo.chartId}_cumulative`);
                        if (ctxCumulative) {
                            // Sort by total cost (ascending) for cumulative chart
                            const sortedEntriesAsc = [...sortedEntries].reverse();

                            // Calculate cumulative costs
                            const cumulativeData = [];
                            const cumulativeLabels = [];
                            let runningTotal = 0;

                            sortedEntriesAsc.forEach((entry, index) => {
                                runningTotal += entry.total;
                                cumulativeData.push(runningTotal);
                                cumulativeLabels.push(`${index + 1}: ${entry.name}`);
                            });

                            new Chart(ctxCumulative, {
                                type: 'bar',
                                data: {
                                    labels: cumulativeLabels,
                                    datasets: [{
                                        label: 'Cumulative Cost ($)',
                                        data: cumulativeData,
                                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                                        borderColor: 'rgba(54, 162, 235, 1)',
                                        borderWidth: 2
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    plugins: {
                                        legend: {
                                            display: true,
                                            position: 'top',
                                            labels: {
                                                font: { size: 11 },
                                                padding: 10
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                title: function(context) {
                                                    return context[0].label;
                                                },
                                                label: function(context) {
                                                    const modelIndex = context.dataIndex;
                                                    const currentModel = sortedEntriesAsc[modelIndex];
                                                    const currentCost = currentModel.total;
                                                    const cumulativeCost = context.parsed.y;

                                                    return [
                                                        `This model: $${currentCost.toFixed(4)}`,
                                                        `Cumulative: $${cumulativeCost.toFixed(4)}`,
                                                        `  Model cost: $${currentModel.modelCost.toFixed(4)}`,
                                                        `  Judge cost: $${currentModel.judgeCost.toFixed(4)}`
                                                    ];
                                                }
                                            }
                                        }
                                    },
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            title: {
                                                display: true,
                                                text: 'Cumulative Cost ($)',
                                                font: { size: 12 }
                                            },
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toFixed(2);
                                                }
                                            }
                                        },
                                        x: {
                                            title: {
                                                display: true,
                                                text: 'Models Added (Cheapest → Most Expensive)',
                                                font: { size: 12 }
                                            },
                                            ticks: {
                                                font: { size: 9 },
                                                maxRotation: 45,
                                                minRotation: 45
                                            }
                                        }
                                    },
                                    layout: {
                                        padding: {
                                            top: 10,
                                            bottom: 10
                                        }
                                    }
                                }
                            });
                        }
                    }
                });
            }, 100);
        }

        // Allow Enter key to trigger fetch
        document.getElementById('judgeModelId').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                fetchPricing();
            }
        });
    </script>
</body>
</html>
